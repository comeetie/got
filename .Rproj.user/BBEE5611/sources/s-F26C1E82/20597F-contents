---
title: "Introduction à R et à dplyr, Games Of Thrones"
author: "Etienne Côme"
date: "**2020**"
output:
  unilur::tutorial_html_solution:
    toc: true
    toc_float: false
    toc_depth: 1
    suffix: ""
    theme: journal
    highlight: kate
    number_sections: no
    number_subsections: no
---

```{r knitr_init, echo=FALSE, cache=FALSE, include=FALSE}
library(knitr)
## Global options
options(max.print="90")
opts_chunk$set(echo=TRUE,
               cache=FALSE, #TRUE
               prompt=FALSE,
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=90)
options(width = 90)

# no margins
knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  }
})

# title margins
knit_hooks$set(sm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,1.2,0))
  }
})

# boxes custom
#devtools::install_github("koncina/unilur")
knitr::opts_template$set(alert = list(box.title = "Watch out!",
                                      box.body = list(fill = "#ffe0d9", colour = "black"),
                                      box.header = list(fill = "#FFAD99", colour = "black"),
                                      box.collapse = NULL,
                                      box.icon = "fa-exclamation-triangle"))
knitr::opts_template$set(solution = list(box.title = "Solution",
                                         box.body = list(fill = "#e6f6e7", colour = "black"),
                                         box.header = list(fill = "#ace1af", colour = "black"),
                                         box.icon = "fa-check-square",
                                         box.collapse = TRUE))
knitr::opts_template$set(information = list(box.title = "Information",
                                            box.body = list(fill = "#bbe8f4", colour = "black"),
                                            box.header = list(fill = "#64c9e6", colour = "black"),
                                            box.icon = "fa-info-circle",
                                            box.collapse = NULL))
knitr::opts_template$set(clues = list(box.title = "Indices",
                                      box.body = list(fill = "#fff9dc", colour = "black"),
                                      box.header = list(fill = "#ffec8b", colour = "black"),
                                      box.icon = "fa-search",
                                      box.collapse = TRUE))
```

![GoT Logo](data/logo.jpeg)
</br>
Dans ce TP nous allons pratiquer un peu de R, en explorant les données de la série Game of thrones avec la librairie `dplyr`. Les données utilisées ont été collectées par Jeffrey Lancaster et sont issues de [ce projet](https://github.com/jeffreylancaster/game-of-thrones).


# Exercise 1 : importer les données et visualiser leurs structures

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}
Importer les fichiers  characters.csv, episodes.csv, scenes.csv et appearances.csv du répertoire data et les tocker dans des variables de mêmes nom.
```


```{block, opts.label = "clues"}
Use `readr::read_csv()`.
```

```{r, solution = TRUE}
library(readr)
characters = read_csv("data/characters.csv")
episodes = read_csv("data/episodes.csv")
scenes = read_csv("data/scenes.csv")
appearances = read_csv("data/appearances.csv")
```

```{block, box.title = "2", box.body = list(fill = "white"), box.icon = "fa-star"}
regarder la taille de la data.frame appearences, observer les variables communes aux tables scenes et appearences. Uiliser les fonctions `str` et `summary` sur les différentes table pour bien comprendre leurs strcutures et leurs relations.
```


```{block, opts.label = "clues"}
Utiliser `nrow, ncol` ou `dim` pour connaitres les dimensions des data.frame. Utiliser la fonction `names` pour connaitres le noms des colones et le l'opérateur `in`.
```

```{r, solution = TRUE}
dim(appearances)
appearances_cols= names(appearances) 
appearances_cols[appearances_cols %in% names(scenes)]
summary(characters)
str(characters)
```

# Exercise 2 : commandes R de bases
```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}
Servez vous de la table scenes pour calculer le nombre de personnages morts dans l'ensemble de la série.
```


```{block, opts.label = "clues"}
Utiliser l'opérateur $ et la fonction `sum`.
```

```{r, solution = TRUE}
sum(scenes$nbdeath)
```

```{block, box.title = "2", box.body = list(fill = "white"), box.icon = "fa-star"}
Servez vous de la table characters pour trouver les 5 plus grand meutriers de la série.
```


```{block, opts.label = "clues"}
Utiliser les fonction `table` et `sort`.
```

```{r, solution = TRUE}
sort(table(characters$killedBy),decreasing = TRUE)[1:5]
```


```{block, box.title = "3", box.body = list(fill = "white"), box.icon = "fa-star"}
Trouvez la durée de la scène la plus longue et l'id de l'episode.
```


```{block, opts.label = "clues"}
Utiliser la fonction `which.max` .
```

```{r, solution = TRUE}
scenes[which.max(scenes$duration),]
```

# Exercise 3 : dplyr
```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}
Trouvez la durée de la scène la plus longue et l'id de l'episode en utilisant dplyr cette fois.
```


```{block, opts.label = "clues"}
Utiliser les fonctions `arrange` et `head`.
```

```{r, solution = TRUE}
library(dplyr)
scenes %>% arrange(desc(duration)) %>% head(1)
```

```{block, box.title = "2", box.body = list(fill = "white"), box.icon = "fa-star"}
Trouvez les personnages de la scenes la plus longue.
```


```{block, opts.label = "clues"}
Utiliser la fonction `left_join` pour faire une jointure.
```

```{r, solution = TRUE}
scenes %>% arrange(desc(duration)) %>% head(1) %>% left_join(appearances)
```

```{block, box.title = "3", box.body = list(fill = "white"), box.icon = "fa-star"}
Trouvez le lieux le plus visités en nombre de scènes.
```


```{block, opts.label = "clues"}
Utiliser les fonctions `group_by` et `summarize` pour faire une aggrégation.
```

```{r, solution = TRUE}
scenes %>% group_by(location) %>% summarise(nbsc = n()) %>% arrange(desc(nbsc))
```

```{block, box.title = "4", box.body = list(fill = "white"), box.icon = "fa-star"}
Trouvez le nombre de scènes à se passant à Port Real.
```


```{block, opts.label = "clues"}
Utiliser la fonction `filter`.
```

```{r, solution = TRUE}
scenes %>% filter(location=="Port Real") %>% group_by(location) %>% summarise(nbsc = n())
```

```{block, box.title = "5", box.body = list(fill = "white"), box.icon = "fa-star"}
Trouvez le lieux précis ou le plus de personages meurent ?
```


```{block, opts.label = "clues"}
Utiliser la fonction `sum` lors de l'aggrégation et la variable subLocation.
```

```{r, solution = TRUE}
scenes %>% group_by(subLocation) %>% summarise(nbd=sum(nbdeath)) %>% arrange(desc(nbd))
```

```{block, box.title = "6", box.body = list(fill = "white"), box.icon = "fa-star"}
Trouvez l'épisode ou Jon Snow est le plus longtemps visible.
```


```{block, opts.label = "clues"}
Utiliser la fonction `sum` lors de l'aggrégation et faites des jointures pour pouvoir aggréger à l'échelle de l'épisode. 
```

```{r, solution = TRUE}
jsnow = appearances %>%filter(name=="Jon Snow") %>% 
  left_join(scenes) %>% left_join(episodes) %>% 
  group_by(name,episodeId,episodeTitle) %>% summarise(screenTime=sum(duration)) %>% 
  arrange(desc(screenTime)) %>% head(1)
```

```{block, box.title = "7", box.body = list(fill = "white"), box.icon = "fa-star"}
Combien de personnages passent plus de 30 minutes à l'ecran sur l'ensemble des saisons ?
```


```{r, solution = TRUE}
appearances %>% left_join(scenes)  %>% group_by(name) %>% summarise(screenTime=sum(duration)) %>% 
  filter(screenTime>30*60) %>% nrow()
```



```{block, box.title = "8", box.body = list(fill = "white"), box.icon = "fa-star"}
Quels sont les deux peronnages qui passent le plus de scènes ensembles ?
```

```{block, opts.label = "clues"}
Faites une jointure de la table appearances avec elle même sur la colonne sceneId.
```

```{r, solution = TRUE}
appearances %>% left_join(appearances,by=c("sceneId"="sceneId")) %>% 
  filter(name.x!=name.y) %>% 
  group_by(name.x,name.y) %>% 
  summarise(nbs=n()) %>% 
  arrange(desc(nbs))
```


```{block, box.title = "9", box.body = list(fill = "white"), box.icon = "fa-star"}
Quels sont les deux peronnages qui passent le plus de temps ensembles ?
```

```{block, opts.label = "clues"}
Faites une jointure de la table appearances avec elle même sur la colonne sceneId, puis une jointure avec la data.frame scenes.
```

```{r, solution = TRUE}
appearances %>% left_join(appearances,by=c("sceneId"="sceneId")) %>% 
  filter(name.x!=name.y) %>% 
  left_join(scenes %>% select(sceneId,duration)) %>%
  group_by(name.x,name.y) %>% 
  summarise(commonTime=sum(duration)) %>% 
  arrange(desc(commonTime))
```

# Exercise 4 : ggplot
```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}
Créer une table jstime contenant pour chaque épisode le temps de présence à l'écran de Jon Snow puis reproduire ce graphique :
```
```{r,echo=FALSE}
library(ggplot2)
jstime = appearances %>% filter(name=="Jon Snow") %>% 
  left_join(scenes) %>% 
  group_by(episodeId) %>% 
  summarise(time=sum(duration))
ggplot(jstime) + 
  geom_line(aes(x=episodeId,y=time),stat='identity')+
  theme_bw()+
  xlab("épisode")+ylab("temps")+
  ggtitle("Temps de présence par épisode de John Snow")
```
```{block, opts.label = "clues"}
Uilisez `geom_bar` mais spécifiez qu'aucune aggrégation ne doit être faites avec l'option `stat='identity'`
```

```{r, solution = TRUE}
library(ggplot2)
jstime = appearances %>% filter(name=="Jon Snow") %>% 
  left_join(scenes) %>% 
  group_by(episodeId) %>% 
  summarise(time=sum(duration))
ggplot(jstime) + 
  geom_bar(aes(x=episodeId,y=time),stat='identity')+
  theme_bw()+
  xlab("épisode")+ylab("temps")+
  ggtitle("Temps de présence par épisode de John Snow")
```

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}
Créer une table jstime contenant pour chaque épisode le temps de présence à l'écran de Jon Snow puis reproduire ce graphique :
```



```{r, fig.height=8, fig.width=9,echo=FALSE}
screenTimePerSeasons = appearances %>% left_join(scenes) %>% 
  left_join(episodes) %>% 
  group_by(name,seasonNum) %>% 
  summarise(screenTime=sum(duration)) %>% 
  arrange(desc(screenTime)) 
screenTimeTotal = screenTimePerSeasons %>% 
  group_by(name) %>% 
  summarise(screenTimeTotal=sum(screenTime))
mainCharacters = screenTimeTotal %>% 
  filter(screenTimeTotal>60*60) %>% 
  arrange(screenTimeTotal) %>% 
  mutate(nameF=factor(name,levels = name))
data = screenTimePerSeasons %>% left_join(mainCharacters) %>% filter(!is.na(nameF))
ggplot(data)+
  geom_bar(aes(y=nameF,x=screenTime/60,fill=factor(seasonNum,level=8:1)),stat="identity")+
  scale_fill_brewer("Saison",palette = "Spectral")+theme_bw()+
  geom_text(data=mainCharacters,aes(y=nameF,x=screenTimeTotal/60+5,label=paste(round(screenTimeTotal/60),'min')),hjust = "left")+
  scale_x_continuous("Temps d'apparition (min)",breaks = seq(0,750,by=120),limits = c(0,780),expand = c(0,1))+
  ylab("")+ggtitle("Temps d'apparition cumulé par personnage et saison")
```


```{r, fig.height=8, fig.width=9,echo=FALSE}
library(sf)
library(tidyr)
land = st_read("./lands-of-ice-and-fire.json","land")
places = st_read("./lands-of-ice-and-fire.json","places")
countries = st_read("./lands-of-ice-and-fire.json","countries")
jsplaces = places %>% left_join(appearances %>% filter(name=="Tyrion Lannister") %>% left_join(scenes) %>% count(subLocation,wt=duration),by=c("name"="subLocation")) %>% filter(!is.na(n))

ggplot()+geom_sf(data=land,fill="ivory",col="ivory3")+
  geom_sf(data=jsplaces,aes(size=n))+
  theme_minimal()+coord_sf(ylim=c(-2,65),xlim=c(-60,40),expand = 0,ndiscr = 0)+
  theme(panel.background = element_rect(fill = "azure",color=NA)) +
  labs(title = "GoT",caption = "Etiennne Côme, 2020",x="",y="")

```

--------------------------------------------

--------------------------------------------

**reproducibility**

```{r}
sessionInfo()
```

